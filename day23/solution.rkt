#lang racket

(require qi
         memoize)

(struct hall [c h] #:transparent)
(struct room [c type n] #:transparent)

;; creature: hall | room
;; state: room-size X creatures
(struct state [room-size creatures] #:transparent)

(define energy (hash 'A 1 'B 10 'C 100 'D 1000))
(define entrances (hash 'A 2 'B 4 'C 6 'D 8))
;; (define rooms (for/hash ([(t e) (in-hash entrances)]) (values e t)))
(define disallowed-halls (~> (entrances) hash-values sep set))
(define hall-length 11)

(define-flow state-creatures-v
  (~> state-creatures set->list sep))

(define-flow organized?
  (~> state-creatures-v
      (all (and room? (~> (-< room-c room-type) eq?)))))

(define-flow (occupied-in-hall s)
  (~> state-creatures-v
      (pass hall?)
      (amp hall-h)
      set))

(define-flow (spots-in-hall s)
  (~>> occupied-in-hall
       (set-subtract (~> (hall-length) range sep set) disallowed-halls)
       set->list))

(define-flow (cs-in-room s t)
  (~> 1> state-creatures-v
      (pass (and room? (~> room-type (eq? t))))))

(define-flow (room-open? s type)
  (~> cs-in-room
      (and (~> (amp room-n) set
               (not (set=? (~> (s) state-room-size range sep (amp add1) set))))
           (all (~> (-< room-c room-type) eq?)))))

(define-flow (spots-in-room s type)
  (~>> cs-in-room
       (amp room-n) set
       (set-subtract (~> (s) state-room-size range sep (amp add1) set))
       set->list))

;; #############
;; #...........#
;; ###B#C#B#D###
;;   #A#D#C#A#
;;   #########

;; (define (example)
;;   (state 2
;;          (set (room 'A 'A 2) (room 'A 'D 2)
;;               (room 'B 'A 1) (room 'B 'C 1)
;;               (room 'C 'B 1) (room 'C 'C 2)
;;               (room 'D 'B 2) (room 'D 'D 1))))

(struct move [src dest] #:transparent)

(define (blocked-in-hall? h1 h2 occupied)
  (~> (h1 h2)
      (if > X _) (== _ add1)
      range sep
      (pass (and (not (= h1)) (not (= h2))))
      (any (set-member? occupied _))))

;; only has to deal with kinds of moves generated by moves-for
(define (blocked? s)
  (define occupied (occupied-in-hall s))
  (match-lambda
    [(move (room _ t n) (room _ ot _))
     (or (~> (s) (cs-in-room t)
             (any (~> room-n (< n))))
         (~> (t ot) (amp (hash-ref entrances _))
             (blocked-in-hall? occupied)))]
    [(move (room _ t n) (hall _ h))
     (or (~> (s) (cs-in-room t)
             (any (~> room-n (< n))))
         (~> (t h) (== (hash-ref entrances _) _)
             (blocked-in-hall? occupied)))]
    [(move (hall _ h) (room _ t _))
     (~> (h t) (== _ (hash-ref entrances _))
         (blocked-in-hall? occupied))]))

(define (moves-for s)
  (match-lambda
    [(and C (room c c n))
     (if (~> (s) (cs-in-room c)
             ;; things below me are not me
             (any (and (~> room-n (> n)) (not (~> room-c (eq? c))))))
       (map (flow (~>> (hall c) (move C)))
            (spots-in-hall s))
       null)]
    [(and C (room c _ _))
     (if (room-open? s c)
       (list (move C (room c c (apply max (spots-in-room s c)))))
       (map (flow (~>> (hall c) (move C)))
            (spots-in-hall s)))]
    [(and C (hall c _))
     (if (room-open? s c)
       (list (move C (room c c (apply max (spots-in-room s c)))))
       null)]))

(define-switch (moves s)
  [organized? '()]
  [else
    (~>> state-creatures set->list
         (append-map (moves-for s))
         (filter (negate (blocked? s))))])

;; hall -> room -> distance
(define-flow (dist-hallway-to-room-entrace h r)
  (~> (== _ (hash-ref entrances _))
      - abs))

(define cost
  (match-lambda
    [(move (room c t n) (room _ ot on))
     (~> (t ot) (amp (hash-ref entrances _))
         - abs
         (+ n on)
         (* (hash-ref energy c)))]
    [(move (room c t n) (hall _ h))
     (~> (h t) dist-hallway-to-room-entrace
         (+ n)
         (* (hash-ref energy c)))]
    [(move (hall c h) (room _ t n))
     (~> (h t) dist-hallway-to-room-entrace
         (+ n)
         (* (hash-ref energy c)))]))

(define (transition m s)
  (match-define (move src dest) m)
  (~> (s)
      (-< state-room-size
          (~> state-creatures
              (set-remove src)
              (set-add dest)))
      state))

;; memo* because we need equal? on state-creatures (sets)
;; but memoize because turn-order to reach a state s doesn't affect the cost to
;; solve starting from s
(define/memo* (solve s)
  (cond
    [(organized? s) 0]
    [else
      (define ms (moves s))
      (cond
        [(empty? ms) #f]
        [else
          (~> (ms) sep
              (amp (~> (-< cost (~> (transition s) solve))
                       (if 2> + #f)))
              (pass number?)
              (if (~> count zero?)
                #f
                min))])]))

(define-flow line->cs
  (~> string->list sep
      (amp (~> string string->symbol))
      (pass (set-member? (set 'A 'B 'C 'D) _))))

(define-flow lines->state
  (~> (select 3 4)
      (== (~> line->cs (== (room 'A 1) (room 'B 1) (room 'C 1) (room 'D 1)))
          (~> line->cs (== (room 'A 2) (room 'B 2) (room 'C 2) (room 'D 2))))
      set
      (state 2 _)))
(define-flow file->state
  (~> file->lines sep lines->state))

(define make-state2
  (let ([extra
          (set
            (room 'D 'A 2) (room 'C 'B 2) (room 'B 'C 2) (room 'A 'D 2)
            (room 'D 'A 3) (room 'B 'B 3) (room 'A 'C 3) (room 'C 'D 3))])
    (match-lambda
      [(state 2 creatures)
       (define creatures*
         (for/set ([c (in-set creatures)])
           (if (~> (c) room-n (= 2))
             (struct-copy room c [n 4])
             c)))
       (state 4 (set-union creatures* extra))])))

(define part1* solve)
(define-flow part1 (~> file->state part1*))
(define-flow part2* (~> make-state2 solve))
(define-flow part2 (~> file->state part2*))

(module+ main
  (command-line
    #:args (input)
    (displayln (time (part1 input)))
    (displayln (time (part2 input)))))
